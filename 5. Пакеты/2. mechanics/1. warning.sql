
begin

    /**
      какие опасности таят пакеты?:

      как и для всех других обьектов
      его пересоздание возможно только когда его никто не использует.

      частота обращений к пакету гораздо выше,
      чем у функций и процедур, потому что в пакете много функций и процедур,
      соответственно его сложнее пересоздать

      в этом плане пакеты на первый взгляд проигрывают функциям,
      решается это всегда разными способами:
      -можно останавливать сессии, бд
      -можно перекомпилировать ночью
      -можно просто ждать



      где тогда использовать пакеты?:

      по моему мнению выйгрыш в упорядоченности и инкапсуляции по смыслу функций
      достаточно большое имеет значение.

      из этого я сделал вывод,
      что достаточно оборачивать в пакеты самые низкие шаги:

      да, они будут тогда максимально часто использоваться,
      но их и разрабатывают максимально универсальными и переиспользуемыми.

      когда дело дойдет до расширения функциональности,
      вы так или иначе столкнетесь с блокировкой,
      большей или меньшей степени особо роли играть не будет.
      она ВСЁ РАВНО будет.

      тогда нужно искать баланс между удобством программирования и администрирования
      --подробнее на лекции 9. Дизайн кода



      еще при перекомпиляции пакета всегда разваливаются все обьекты,
      которые использовали его константы или методы,
      если их значение было изменено или спецификация соответственно

      избежать этого можно (но не обязательно) следующей хитростью:
      аналог "вычисляемых полей".
      достигается:
      -использованием функций,
      -режима DETERMINISTIC в функции,
      -и синтаксиса вызова без скобок
     */

end;
/



create or replace package student.pkg_util
as
    /**
      Детерминированный алгоритм - это алгоритм,
      который возвращает один и тот же набор выходных значений
      для одного и того же набора входных значений,
      при этом осуществляя одну и ту же последовательность действий.
     */

    function c_calc_constant return varchar2 deterministic;

    function pass_number(
        i number
    )
    return number
    deterministic;

end;
/

create or replace package body student.pkg_util
as

    function c_calc_constant return varchar2 deterministic as begin return 'c_calc_constant'; end;

    function pass_number(
        i number
    )
    return number
    deterministic
    is
    begin
        dbms_output.put_line ('pass_number executed');
        return i;
    end;

end;
/



declare

    n number := 0;

begin

    dbms_output.put_line(student.pkg_util.c_calc_constant);

    /**
      польза будет достигнута только если детерминированная подпрограмма (процедура или функция)
      не имеет побочных эффектов.

      что же может считаться побочным эффектом для функции на PL/SQL?:
      -любой (то есть совсем любой) DML-оператор
      -использование переменной, объявленной вне этой функции
      -вызов любой не-детерминированной подпрограммы

      как достигается польза?:
      -это позволяет oracle использовать эту функцию для создания индекса, основанного на функции
      -это может (но не обязано) улучшить производительность
      за счет кэширования и переиспользования результата выполнения этой функции
     */

    for i in(
        select student.pkg_util.pass_number(1)
        --1
        --"level"
        --not "level"
        --case when mod(level,2) = 0 then 0 else 1 end
        from dual
        connect by level <= 20
    )
    loop
        n := n + 1;
    end loop;

    dbms_output.put_line (n);

    /**
      обратите внимание, что, хотя функция была вызвана 20 раз,
      она была исполнена только один раз.

      oracle создала короткоживущий кэш,
      действительный только для этой функции
      и только в этом вызове
      (блоке PL/SQL или SQL-запросе, из которого мы обратились к функции).
     */

end;
/
