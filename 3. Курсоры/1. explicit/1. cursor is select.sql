
/**
  Курсор - это указатель на эту контекстную область
  PL/SQL управляет контекстной областью с помощью курсора
 */

--ЯВНЫЕ

--статические курсоры
declare

    --курсор без параметров
    cursor cursor_1 is
    select h.id_hospital, h.name
    from student.hospitals h
    where h.id_hospital = 1;

    --запись
    type record_1 is record (
        id_hospital number,
        name varchar2(100)
    );
    v_record_1 record_1;

    --с параметрами
    cursor cursor_2 (
        p_id_hospital in number --подробнее на лекции 4. Хранимые процедуры
    )
    is
    select h.id_hospital, h.name
    from student.hospitals h
    where h.id_hospital = p_id_hospital;

    type record_2 is record (
        id_hospital number,
        name varchar2(100)
    );
    v_record_2 record_2;

    --с блоком return
    cursor cursor_3
    return student.hospitals%rowtype
    --сильнотипизированный/слаботипизированный
    is
    select *
    from student.hospitals;

    v_record_3 student.hospitals%rowtype;

    /**
      любой идентификатор в pl/sql обладает следующими свойствами:
      - длина — до 30 символов
      - должны начинаться с буквы
      - могут включать символы «$», «_» и «#»
      - не должны содержать пропусков
    */

    /**
      имя явного курсора должно соответствовать тем же правилам,
      что и остальные идентификаторы pl/sql

      имя курсора не является переменной — это идентификатор указателя на запрос.
      имени курсора не присваивается значение, его нельзя применять в выражениях.
      курсор используется только в командах OPEN, CLOSE и FETCH,
      а также для уточнения атрибута курсора
    */

    v_count number;

begin

    --использование (открытие, закрытие)

    --Открытие курсора выделяет память для курсора
    -- и делает его готовым для извлечения в него строк,
    -- возвращаемых оператором SQL
    open cursor_1;

    --Выборка курсора вовлекает доступ к одной строке за один раз
    fetch cursor_1 into v_record_1;

    --атрибуты курсора

    --TRUE, если строка выбрана успешно
    if cursor_1%found then

        --не удачная выборка не генерирует исключение,
        --перезаписи на null нет

        null; --code

    --TRUE, если не была выбрана ни одна строка
    elsif cursor_1%notfound then

        null; --code

    --TRUE, если заданный курсор открыт
    elsif cursor_1%isopen then

        null; --code

    end if;

    --Количество строк,
    --выбранных из заданного курсора до настоящего момента
    v_count := cursor_1%rowcount;

    dbms_output.put_line(v_record_1.id_hospital);

    --Закрытие курсора означает освобождение выделенной памяти
    close cursor_1;
    --иначе утечка памяти

    /**
      все символы до ключевого слова IS образуют спецификацию,
      а после IS следует тело курсора.

      разделение объявления курсора может служить двум целям:

      1. сокрытие информации.
      курсор в пакете представляет собой «черный ящик».
      это удобно для программистов, потому что им не нужно ни писать,
      ни даже видеть команду SELECT.
      достаточно знать, какие записи возвращает этот курсор,
      в каком порядке и какие столбцы они содержат.
      программист, работающий с пакетом, использует курсор
      как любой другой готовый элемент.
      при разделении обьявления через блок return
      мы показываем возвращаемый тип

      (подробнее на лекции 5. Пакеты)

      2. минимум перекомпиляции.
      если скрыть определение запроса в теле пакета,
      то изменения в команду SELECT можно будет вносить,
      не меняя заголовок курсора в спецификации пакета.
      это позволяет совершенствовать, исправлять
      и повторно компилировать код
      без перекомпиляции спецификации пакета,
      благодаря чему зависящие от этого пакета программы
      не будут помечены как недействительные
      и их также не нужно будет перекомпилировать.

      (подробнее на лекции 4. Хранимые процедуры)
    */

    --открытие курсора с параметрами
    open cursor_2(2);

    fetch cursor_2 into v_record_2;

    dbms_output.put_line(v_record_2.id_hospital);

    close cursor_2;

    --перебор курсора в цикле
    open cursor_3;

    loop
        fetch cursor_3 into v_record_3;

        exit when cursor_3%notfound;

        dbms_output.put_line (v_record_3.name);
    end loop;

    close cursor_3;

end;
/